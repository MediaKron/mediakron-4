{"version":3,"file":"index.min.js","sources":["../src/minify-utils.js","../src/minify.js","../src/label.js"],"sourcesContent":["// @flow\n// babel-plugin-styled-components\n// https://github.com/styled-components/babel-plugin-styled-components/blob/8d44acc36f067d60d4e09f9c22ff89695bc332d2/src/minify/index.js\n\nconst multilineCommentRegex = /\\/\\*[^!](.|[\\r\\n])*?\\*\\//g\nconst lineCommentStart = /\\/\\//g\nconst symbolRegex = /(\\s*[;:{},]\\s*)/g\n\n// Counts occurences of substr inside str\nconst countOccurences = (str, substr) => str.split(substr).length - 1\n\n// Joins substrings until predicate returns true\nconst reduceSubstr = (substrs, join, predicate) => {\n  const length = substrs.length\n  let res = substrs[0]\n\n  if (length === 1) {\n    return res\n  }\n\n  for (let i = 1; i < length; i++) {\n    if (predicate(res)) {\n      break\n    }\n\n    res += join + substrs[i]\n  }\n\n  return res\n}\n\n// Joins at comment starts when it's inside a string or parantheses\n// effectively removing line comments\nexport const stripLineComment = (line: string) =>\n  reduceSubstr(\n    line.split(lineCommentStart),\n    '//',\n    str =>\n      !str.endsWith(':') && // NOTE: This is another guard against urls, if they're not inside strings or parantheses.\n      countOccurences(str, \"'\") % 2 === 0 &&\n      countOccurences(str, '\"') % 2 === 0 &&\n      countOccurences(str, '(') === countOccurences(str, ')')\n  )\n\nexport const compressSymbols = (code: string) =>\n  code.split(symbolRegex).reduce((str, fragment, index) => {\n    // Even-indices are non-symbol fragments\n    if (index % 2 === 0) {\n      return str + fragment\n    }\n\n    // Only manipulate symbols outside of strings\n    if (\n      countOccurences(str, \"'\") % 2 === 0 &&\n      countOccurences(str, '\"') % 2 === 0\n    ) {\n      return str + fragment.trim()\n    }\n\n    return str + fragment\n  }, '')\n\n// Detects lines that are exclusively line comments\nconst isLineComment = line => line.trim().startsWith('//')\nconst linebreakRegex = /[\\r\\n]\\s*/g\n\nexport const minify = (code: string) => {\n  const newCode = code\n    .replace(multilineCommentRegex, '\\n') // Remove multiline comments\n    .split(linebreakRegex) // Split at newlines\n    .filter(line => line.length > 0 && !isLineComment(line)) // Removes lines containing only line comments\n    .map(stripLineComment) // Remove line comments inside text\n    .join(' ') // Rejoin all lines\n\n  return compressSymbols(newCode)\n}\n","// @flow\nimport { minify } from './minify-utils'\n\nexport function getExpressionsFromTemplateLiteral(node: *, t: *): Array<*> {\n  const raw = createRawStringFromTemplateLiteral(node)\n  const minified = minify(raw)\n  return replacePlaceholdersWithExpressions(minified, node.expressions || [], t)\n}\n\nconst interleave = (strings: Array<*>, interpolations: Array<*>) =>\n  interpolations.reduce(\n    (array, interp, i) => array.concat([interp], strings[i + 1]),\n    [strings[0]]\n  )\n\nfunction getDynamicMatches(str: string) {\n  const re = /xxx(\\d+)xxx/gm\n  let match\n  const matches = []\n  while ((match = re.exec(str)) !== null) {\n    matches.push({\n      value: match[0],\n      p1: parseInt(match[1], 10),\n      index: match.index\n    })\n  }\n\n  return matches\n}\n\nfunction replacePlaceholdersWithExpressions(\n  str: string,\n  expressions: Array<*>,\n  t: *\n) {\n  const matches = getDynamicMatches(str)\n  if (matches.length === 0) {\n    if (str === '') {\n      return []\n    }\n    return [t.stringLiteral(str)]\n  }\n  const strings = []\n  const finalExpressions = []\n  let cursor = 0\n\n  matches.forEach(({ value, p1, index }, i) => {\n    const preMatch = str.substring(cursor, index)\n    cursor = cursor + preMatch.length + value.length\n    if (preMatch) {\n      strings.push(t.stringLiteral(preMatch))\n    } else if (i === 0) {\n      strings.push(t.stringLiteral(''))\n    }\n\n    finalExpressions.push(expressions[p1])\n    if (i === matches.length - 1) {\n      strings.push(t.stringLiteral(str.substring(index + value.length)))\n    }\n  })\n\n  return interleave(strings, finalExpressions).filter(\n    // $FlowFixMe\n    (node: StringLiteral) => {\n      return node.value !== ''\n    }\n  )\n}\n\nfunction createRawStringFromTemplateLiteral(quasi: {\n  quasis: Array<{ value: { cooked: string } }>\n}) {\n  let strs = quasi.quasis.map(x => x.value.cooked)\n\n  const src = strs\n    .reduce((arr, str, i) => {\n      arr.push(str)\n      if (i !== strs.length - 1) {\n        arr.push(`xxx${i}xxx`)\n      }\n      return arr\n    }, [])\n    .join('')\n    .trim()\n  return src\n}\n","// @flow\nexport function getLabelFromPath(path: *, t: *) {\n  return getIdentifierName(path, t)\n}\n\nfunction getDeclaratorName(path, t) {\n  // $FlowFixMe\n  const parent = path.findParent(p => p.isVariableDeclarator())\n  return parent && t.isIdentifier(parent.node.id) ? parent.node.id.name : ''\n}\n\nfunction getIdentifierName(path, t) {\n  let classParent\n  if (path) {\n    // $FlowFixMe\n    classParent = path.findParent(p => t.isClass(p))\n  }\n  if (classParent && classParent.node.id) {\n    return t.isIdentifier(classParent.node.id) ? classParent.node.id.name : ''\n  } else if (\n    classParent &&\n    classParent.node.superClass &&\n    classParent.node.superClass.name\n  ) {\n    return `${getDeclaratorName(path, t)}(${classParent.node.superClass.name})`\n  }\n\n  return getDeclaratorName(path, t)\n}\n"],"names":["multilineCommentRegex","lineCommentStart","symbolRegex","countOccurences","str","substr","split","length","stripLineComment","line","substrs","join","predicate","res","i","reduceSubstr","endsWith","linebreakRegex","minify","code","reduce","fragment","index","trim","compressSymbols","replace","filter","startsWith","isLineComment","map","interleave","strings","interpolations","array","interp","concat","getDeclaratorName","path","t","parent","findParent","p","isVariableDeclarator","isIdentifier","node","id","name","strs","raw","quasis","x","value","cooked","arr","push","expressions","matches","match","re","exec","parseInt","getDynamicMatches","stringLiteral","finalExpressions","cursor","forEach","p1","preMatch","substring","replacePlaceholdersWithExpressions","classParent","isClass","superClass","getIdentifierName"],"mappings":"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"}